{
  "name": "midware",
  "version": "0.1.2",
  "description": "Module for creating connect-style middlewares. Dependency-free. Runs in the browser and node.js",
  "main": "midware.js",
  "scripts": {
    "test": "mocha",
    "browser": "uglifyjs midware.js --mangle --source-map midware.min.js.map --source-map-url http://cdn.rawgit.com/h2non/midware/0.1.2/midware.min.js.map > midware.min.js"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/h2non/midware.git"
  },
  "keywords": [
    "middleware",
    "middle-ware",
    "use",
    "custom",
    "connect"
  ],
  "author": {
    "name": "Tomas Aparicio"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/h2non/midware/issues"
  },
  "homepage": "https://github.com/h2non/midware",
  "devDependencies": {
    "mocha": "^1.21.4",
    "uglify-js": "^2.4.20"
  },
  "readme": "# midware [![Build Status](https://travis-ci.org/h2non/midware.svg?branch=master)](https://travis-ci.org/h2non/midware)\n\nmidware is a tiny module for creating middleware for any node or browser application. \nInspired by the middleware pattern by [connect](https://github.com/senchalabs/connect).\n\nIt's only ~60 SLOC.\n\n### Example\n\n```js\nvar use = require('midware')();\nvar message = {};\n\nuse(function(msg, next) {\n  // msg === message\n  next();\n});\n\nuse.run(message, function(err) {\n  if (err) return console.log(err);\n  // finished\n});\n```\n\n## Installation\n\n### Node\n\nTo install mware in a Node application use npm.\n\n```\nnpm install midware\n```\n\n### Browser\n\n```\nbower install midware\n```\n\n```\ncomponent install h2non/midware\n```\n\n```\n<script src=\"//cdn.rawgit.com/h2non/midware/0.1.2/midware.js\"></script>\n```\n\n## Test\n\nTo run tests use npm.\n\n```\n$ npm install\n$ npm test\n```\n\n## Documentation\n\n### Basic Usage\n\nMiddleware is useful for creating a plugin system or configuring anything within an application. To use mware just require it and make a call to the module.\n\n```js\nvar mware = require('mware');\nvar use = mware();\n```\n\nThis will return a `use` function which when passed a callback will add it a waterfall sequence that will be invoked one after the other whenever the middleware is run.\n\n```js\nuse(function(next) {\n  // mad science here\n  next();\n});\n```\n\nCallbacks are given a `next` function which will **always** be the *last* argument. Calling `next` will tell the middleware to call the next callback in the use sequence or will complete its run. To run the callback sequence call the method `run` on the `use` function.\n\n```js\nuse.run(function(err) {\n  if (err) { return console.log(err); }\n  // all done professor\n});\n```\n\n`run` takes any amount of parameters that the callbacks will passed whenever run.\n\n```js\nuse(function(first, last, next) {\n  console.log('Hello %s, %s', first, last);\n  next();\n});\nuse.run('Christopher', 'Turner');\n```\n\n### Stopping\n\nWhenever a callback should throw an exception or wish to stop the middleware from running any more calls. Give `next` an error or explicitly tell it stop.\n\n```js\nuse(function(next) {\n  next(new Error()); // stops middleware and gives error\n  next(null, true); // tells middleware to stop\n});\n```\n\n### Apply Context\n\nInstead of binding context to callbacks, send the context to `mware`.\n\n```js\nvar context = {};\nvar use = mware(context);\nuse(function(next) {\n  // this === context\n  next();\n});\nuse.run(function(err) {\n  // this === context\n});\n```\n\n## API\n\n#### mware(*[context]*)\n#### use(*&lt;callback...&gt;*)\n#### use.run(*[args...]*, *[done]*)\n\n## License\n\n[MIT](LICENSE)\n\nCopyright (c) 2014 [Christopher Turner](https://github.com/tur-nr)\nCopyright (c) 2015 [Tomas Aparicio](https://github.com/h2non)\n",
  "readmeFilename": "README.md",
  "gitHead": "476993a5d3245bc9f468d4bb201289418d01e9f4",
  "_id": "midware@0.1.2",
  "_shasum": "37a031d67ff8a07e87700714142ba747ffd79aa2",
  "_from": "midware@>=0.1.1 <0.2.0"
}
